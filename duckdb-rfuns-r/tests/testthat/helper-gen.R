if (Sys.getenv("CI") == "" ) {

  Sys.setlocale("LC_COLLATE", "C")
  Sys.setenv("TZ" = "UTC")

  # TODO: this should live in the package somewhere
  udfs <- c(
    # relop
    "=="  = "r_base::==",
    "!="  = "r_base::!=",
    "<"   = "r_base::<",
    "<="  = "r_base::<=",
    ">"   = "r_base::>",
    ">="  = "r_base::>=",

    # +
    "+"   = "r_base::+"
  )

  convert_expr <- function(expr) {
    fun <- as.character(rlang::node_car(expr))

    args <- as.list(expr[-1])
    env <- new.env()
    env$time <- as.POSIXct(strptime('2024-02-21 14:00:00', format = '%Y-%m-%d %H:%M:%S'))
    env$date <- as.Date("2024-02-21")
    env$NA_time <- as.POSIXct(NA)
    env$NA_date <- as.Date(NA)
    args <- lapply(args, eval, envir = env)
    names(args) <- paste0("x", seq_along(args))

    list(
      fun = fun,
      udf = udfs[[fun]],
      data = tibble::as_tibble(args),
      expression = constructive::deparse_call(expr),
      expected = constructive::construct(eval(expr, envir = env))$code
    )
  }

  gen_dir <- system.file(package = "duckdbrfuns", "tests", "testthat", "gen")

  # generate (eq,lt).R from relop.txt ------------------------------------------
  relop_txt <- c(
    paste("# Generated by helper-gen.R + relop.txt: do not edit", "by hand"),
    readLines(file.path(gen_dir, "relop.txt"))
  )
  relop_err_txt <- c(
    paste("# Generated by helper-gen.R + relop-err.txt: do not edit", "by hand"),
    readLines(file.path(gen_dir, "relop-err.txt"))
  )


  op <- c("eq" = "==", "neq" = "!=",
          "lt" = "<", "lte" = "<=",
          "gt" = ">", "gte" = ">=")
  for (i in seq_along(op)) {
    txt <- gsub("<=>", op[i], relop_txt, fixed = TRUE)
    txt_err <- gsub("<=>", op[i], relop_err_txt, fixed = TRUE)
    name <- names(op)[i]
    target <- file.path(gen_dir, paste0("relop-", name, ".R"))
    target_err <- file.path(gen_dir, paste0("relop-err-", name, ".R"))
    writeLines(txt, target)
    writeLines(txt_err, target_err)
    message(paste("\U2705 generating:", basename(target), "and", basename(target_err)," from relop(-err).txt"))
  }

  # generate test files -----------------------------------------------------
  gen_files <- list.files(gen_dir, pattern = "[.][rR]$")
  for (f in gen_files) {
    is_err <- grepl("-err-", f)
    test_file_path <- file.path(system.file(package = "duckdbrfuns", "tests", "testthat"), paste0("test-generated-", f))
    message(paste("\U2705 generating:", basename(test_file_path)))
    test_file <- file(test_file_path, open = "w")
    cat("# Generated by helper-gen.R: do not edit", "by hand\n", file = test_file)

    expressions <- parse(file.path(gen_dir, f))
    header <- sapply(expressions, is.character)
    group <- cumsum(header)

    description <- as.character(expressions[header])
    for (i in seq_along(description)) {
      desc <- description[[i]]

      exprs <- lapply(tail(expressions[group == i], -1), convert_expr)

      for (expr in exprs) {
        in_df <- paste(constructive::construct(expr$data)$code, collapse = "\n")
        args_references <- paste(glue::glue('        duckdb:::expr_reference("{names(expr$data)}")'), collapse = ", \n")

        if (is_err) {
          test_expr <- glue::glue(r"[
test_that(r"({desc} :: {expr$expression})", {{
  con <- local_duckdb_con()
  in_df <- {in_df}
  in_rel <- duckdb:::rel_from_df(con, in_df)

  expect_snapshot(error = TRUE, duckdb:::rel_project(
    in_rel,
    list(duckdb:::expr_function(
      "{expr$udf}",
      list(
{args_references}
      )
    ))
  ))
}})

]")
        } else {
          test_expr <- glue::glue(r"[
test_that(r"({desc} :: {expr$expression})", {{
  con <- local_duckdb_con()
  in_df <- {in_df}
  in_rel <- duckdb:::rel_from_df(con, in_df)
  out_rel <- duckdb:::rel_project(
    in_rel,
    list(duckdb:::expr_function(
      "{expr$udf}",
      list(
{args_references}
      )
    ))
  )
  out_df <- duckdb:::rel_to_altrep(out_rel)

  expect_identical(out_df[, 1], {expr$expected})
}})


]")

        }

        cat(test_expr, file = test_file)
      }
    }

    close(test_file)
  }

}
