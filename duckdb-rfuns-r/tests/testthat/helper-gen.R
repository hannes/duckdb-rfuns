convert_arg <- function(arg) {
  if (is.call(arg)) stop("not supported yet, will deal with special cases later")
  arg
}

# TODO: this should live in the package somewhere
udfs <- c(
  "==" = "r_base::==",
  "+"  = "r_base::+"
)

convert_expr <- function(expr) {
  fun <- as.character(rlang::node_car(expr))

  args <- as.list(expr[-1])
  args <- lapply(args, convert_arg)
  names(args) <- paste0("x", seq_along(args))

  list(fun = fun, udf = udfs[[fun]], data = tibble::as_tibble(args), expression = deparse(expr, nlines = 1L))
}

gen_dir <- file.path("tests", "testthat", "gen")
gen_files <- list.files(gen_dir, pattern = "[.][rR]$")

for (f in gen_files) {
  test_file <- file(file.path("tests", "testthat", paste0("test-generated-", f)), open = "w")
  cat("# Generated by helper-gen.R: do not edit by hand\n", file = test_file)

  expressions <- parse(file.path(gen_dir, f))
  header <- sapply(expressions, is.character)
  group <- cumsum(header)

  description <- as.character(expressions[header])
  for (i in seq_along(description)) {
    desc <- description[[i]]

    exprs <- lapply(tail(expressions[group == i], -1), convert_expr)

    for (expr in exprs) {
      in_df <- paste(constructive::construct(expr$data)$code, collapse = "\n")
      args_references <- paste(glue::glue("                duckdb:::expr_reference('{names(expr$data)}')"), collapse = ", \n")

      test_expr <- glue::glue(r"[
test_that('{desc} :: {expr$expression}', {{
    con <- local_con()
    in_df <- {in_df}
    in_rel <- duckdb:::rel_from_df(con, in_df)
    out_rel <- duckdb:::rel_project(
        in_rel,
        list(duckdb:::expr_function(
          '{expr$udf}',
          list(
{args_references}
          )
        ))
    )
    out_df <- duckdb:::rel_to_altrep(out_rel)
    expect_snapshot(out_df)
}})

]")

      cat(test_expr, file = test_file)
    }



  }

  close(test_file)
}

